% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/downloadInputs.R
\name{postProcess.spatialObjects}
\alias{postProcess.spatialObjects}
\title{Post processing for \code{spatialObjects}}
\usage{
\method{postProcess}{spatialObjects}(x, targetFilePath, studyArea = NULL,
  rasterToMatch = NULL, overwrite = TRUE, useSAcrs = FALSE, ...)
}
\arguments{
\item{x}{A \code{Spatial*}, \code{sf} or \code{Raster*} object.}

\item{targetFilePath}{Character string. This is used if \code{postProcessedFilename}
is \code{TRUE}. The resulting post-processed filename will be
\code{.prefix(basename(targetFilePath), "Small")}.}

\item{studyArea}{Template \code{SpatialPolygons*} object used for masking, after cropping.
If not in same CRS, then it will be \code{spTransform}ed to
CRS of \code{x} before masking. Currently, this function will not reproject the
\code{x}. \code{\link{postProcess.spatialObjects}}}

\item{rasterToMatch}{Template \code{Raster*} object used for cropping (so extent should be
the extent of desired outcome), reprojecting (including changing the
resolution and projection). See details in
\code{\link{postProcess.spatialObjects}}.}

\item{overwrite}{Logical. Should downloading and all the other actions occur even if they
pass the checksums or the files are all there.}

\item{useSAcrs}{Logical. If \code{FALSE}, the default, then the desired projection
will be taken from \code{rasterToMatch} or none at all.
If \code{TRUE}, it will be taken from \code{studyArea}.}

\item{...}{\code{\link{cropInputs}}, \code{\link{projectInputs}},
\code{\link{maskInputs}}, \code{\link{determineFilename}},
\code{\link{writeOutputs}}. These then pass \code{...} into other functions, like
\code{\link[raster]{writeRaster}}, or
\code{sf::st_write}. This might include potentially important
arguments like \code{datatype}, \code{format}. Also passed to \code{projectRaster},
with likely important arguments such as \code{method = "bilinear"}}
}
\description{
The method for spatialObjects (\code{Raster*} and \code{Spatial*}) will
crop, reproject, and mask, in that order.  This function is a wrapper for
\code{\link{cropInputs}}, \code{\link{maskInputs}} and
\code{\link{writeOutputs}}, with a decent amount of data manipulating
between these calls so that the crs match.
}
\section{Passing \code{rasterToMatch} and/or \code{studyArea}}{


Depending on which of these were passed, different things will happen to the \code{targetFile}
located at \code{targetFilePath}.

\subsection{If \code{targetFile} is a \code{Raster*} object:}{
  \tabular{lccc}{
                      \tab \code{rasterToMatch} \tab \code{studyArea} \tab             Both \cr
    \code{extent}     \tab Yes                  \tab   Yes        \tab \code{rasterToMatch} \cr
    \code{resolution} \tab Yes                  \tab   No         \tab \code{rasterToMatch} \cr
    \code{projection} \tab Yes                  \tab   No*        \tab \code{rasterToMatch}*\cr
    \code{alignment}  \tab Yes                  \tab   No         \tab \code{rasterToMatch} \cr
    \code{mask}       \tab No**                 \tab   Yes        \tab \code{studyArea}**   \cr
  }
  * Can be overridden with \code{useSAcrs}
  ** Will mask with \code{NA}s from \code{rasterToMatch} if \code{maskWithRTM}
}

\subsection{If \code{targetFile} is a \code{Spatial*} object:}{
  \tabular{lccc}{
                      \tab \code{rasterToMatch} \tab \code{studyArea} \tab             Both \cr
    \code{extent}     \tab Yes                  \tab   Yes        \tab \code{rasterToMatch} \cr
    \code{resolution} \tab NA                   \tab   NA         \tab NA                   \cr
    \code{projection} \tab Yes                  \tab   No*        \tab \code{rasterToMatch}*\cr
    \code{alignment}  \tab NA                   \tab   NA         \tab NA                   \cr
    \code{mask}       \tab No                   \tab   Yes        \tab \code{studyArea}     \cr
  }
  * Can be overridden with \code{useSAcrs}
}
}

